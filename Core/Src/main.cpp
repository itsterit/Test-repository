/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "stm32f1xx.h"
#include "main.h"
#include <ClockControl/ClockControl.h>
#include <DmaControl/DmaControl.h>
#include <UartWrap/Uart.h>

int i = 0;
int main(void)
{
  /**
   * @brief   Start HSI clock
   *
   * @details Returns 1 if launch is successful
   * @details HSE not divided for PLL entry
   */
  ClockControl::HSE::Start_HSE();
  ClockControl::HSE::PLL::Clean_PLLXTPRE();
  /**
   * @brief   PLL clocking from HSE
   *          Set PLL as system clock
   * @details Written only when PLL is disabled
   * @details On successful launch pll returns 1
   */
  ClockControl::HSE::PLL::Set_PLLSRC_HSE();
  ClockControl::HSE::PLL::Set_PLL_MUL(6);
  ClockControl::HSE::PLL::Start_PLL();
  ClockControl::HSE::PLL::Set_SW_PLL();
  /**
   * @brief   installation of frequency dividers
   *
   * @details AHB bus, core, memory and DMA - 48Mhz
   * @details Cortex System timer           - 48Mhz
   * @details FCLK Cortex                   - 48Mhz
   * @details APB1 peripherals              - 24Mhz
   * @details APB1 timers                   - 48Mhz
   * @details APB2 peripherals              - 48Mhz
   * @details APB1 timers                   - 48Mhz
   * @details To ADC                        - 12Mhz
   */
  ClockControl::Set_AHB_Prescaler(1);
  ClockControl::Set_APB1_Prescaler(2);
  ClockControl::Set_APB2_Prescaler(1);
  ClockControl::Set_ADC_Prescaler(4);

  /*
  DMA_Config DMA_Ch1_cfg;
  DMA_Ch1_cfg.MEM2MEM = MEM2MEM_Disabled;
  DMA_Ch1_cfg.PL      = PL_VeryHigh;
  DMA_Ch1_cfg.MSIZE   = MSIZE_16bits;
  DMA_Ch1_cfg.PSIZE   = PSIZE_16bits;
  DMA_Ch1_cfg.MINC    = MINC_Disabled;
  DMA_Ch1_cfg.PINC    = PINC_Disabled;
  DMA_Ch1_cfg.CIRC    = CIRC_Enabled;
  DMA_Ch1_cfg.DIR     = Read_From_Peripheral;
  DMA_Ch1_cfg.TEIE    = TEIE_Enabled;
  DMA_Ch1_cfg.HTIE    = HTIE_Disabled;
  DMA_Ch1_cfg.TCIE    = TCIE_Enabled;
  DMA_Ch1_cfg.EN      = EN_Enabled;
  DmaControl Dma_Ch1(DMA1, DMA1_Channel1, &DMA_Ch1_cfg);
  */

  PinSet();
  Uart2_Ini(USART2, 24000000, 9600);
  ADC1_IN9_PB1_ini();

  while (1)
  {
    RCC->AHBENR |= RCC_AHBENR_DMA1EN;
    DMA1_Channel1->CNDTR = 1;                  // сколько кадров данных подлежит передаче
    DMA1_Channel1->CMAR = (uint32_t)&i;        // адрес памяти
    DMA1_Channel1->CPAR = (uint32_t)&ADC1->DR; // Загружаем адрес регистра DR
    DMA1_Channel1->CCR |= DMA_CCR_PSIZE_0    // размерность данных периферии 16 бит
                          | DMA_CCR_MSIZE_0; // размерность данных памяти 16 bit
    NVIC_EnableIRQ(DMA1_Channel1_IRQn);

    ADC1->CR2 |= ADC_CR2_ADON;
    ADC1->CR2 |= ADC_CR2_SWSTART;
    DMA1_Channel1->CCR |= DMA_CCR_TCIE | DMA_CCR_TEIE | DMA_CCR_EN;

    for (int i = 0; i != 10000; i++)
    {
    }
  }
}
