/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "stm32f1xx.h"
#include "main.h"
#include <ClockControl/ClockControl.h>

short Uart2_Cond = 1;
short Uart2_Counter = 0;
short Uart2_Len = 0;
char Uart2_BufSend[100] = {0};

char LibA[10] = {'A', '\n'};

int main(void)
{
  /**
   * @brief   Start HSI clock
   *
   * @details Returns 1 if launch is successful
   * @details HSE not divided for PLL entry
   */
  ClockControl::HSE::Start_HSE();
  ClockControl::HSE::PLL::Clean_PLLXTPRE();
  /**
   * @brief   PLL clocking from HSE
   *          Set PLL as system clock
   * @details Written only when PLL is disabled
   * @details On successful launch pll returns 1
   */
  ClockControl::HSE::PLL::Set_PLLSRC_HSE();
  ClockControl::HSE::PLL::Set_PLL_MUL(6);
  ClockControl::HSE::PLL::Start_PLL();
  ClockControl::HSE::PLL::Set_SW_PLL();
  /**
   * @brief   installation of frequency dividers
   *
   * @details AHB bus, core, memory and DMA - 48Mhz
   * @details Cortex System timer           - 48Mhz
   * @details FCLK Cortex                   - 48Mhz
   * @details APB1 peripherals              - 24Mhz
   * @details APB1 timers                   - 48Mhz
   * @details APB2 peripherals              - 48Mhz
   * @details APB1 timers                   - 48Mhz
   * @details To ADC                        - 12Mhz
   */
  ClockControl::Set_AHB_Prescaler(1);
  ClockControl::Set_APB1_Prescaler(2);
  ClockControl::Set_APB2_Prescaler(1);
  ClockControl::Set_ADC_Prescaler(4);

  Uart2_Ini(USART2, 24000000, 9600);

  PinSet();

  /**
   * @brief: Start DMA ini
   */
  RCC->AHBENR |= RCC_AHBENR_DMA1EN;
  DMA1->ISR = 0x00;                    // DMA interrupt status register
  DMA1->IFCR = 0x00;                   // DMA interrupt flag clear register
  
  DMA1_Channel1->CCR = 0x00;
  DMA1_Channel1->CCR |= (00 << DMA_CCR_MEM2MEM_Pos)  // Memory to memory mode disabled
  | (00 << DMA_CCR_PL_Pos)                           // Channel priority level
  | (00 << DMA_CCR_MSIZE_Pos)                        // Memory size
  | (00 << DMA_CCR_MSIZE_Pos)                        // Memory size
  | (00 << DMA_CCR_PSIZE_Pos)                        // Peripheral size
  | (00 << DMA_CCR_MINC_Pos)                         // Memory increment mode
  | (00 << DMA_CCR_PINC_Pos)                         // Peripheral increment mode
  | (00 << DMA_CCR_CIRC_Pos)                         // Circular mode
  | (00 << DMA_CCR_DIR_Pos)                          // Data transfer direction
  | (00 << DMA_CCR_TEIE_Pos)                         // Transfer error interrupt enable
  | (00 << DMA_CCR_HTIE_Pos)                         // Half transfer interrupt enable
  | (00 << DMA_CCR_TCIE_Pos)                         // Transfer complete interrupt enable
  | (00 << DMA_CCR_EN_Pos);                          // Channel enable

  DMA1_Channel1->CNDTR = 0x00;                      // сколько кадров данных подлежит передаче 
  DMA1_Channel1->CPAR  = 0x00;                      // адрес памяти
  DMA1_Channel1->CPAR  = 0x00;                      // адрес периферийного устройства


  while (1)
  {
    GPIOC->ODR ^= GPIO_ODR_ODR13;

    USART2->SR = 0x00;
    USART2->CR1 |= USART_CR1_TCIE;
    USART2->DR = LibA[0];

    for (int i = 0; i != 1000000; i++)
    {
    }
  }
}
